# Mapping Generator

A .NET source generator that allows you to map from one type to another with a similar signature
in a strongly typed manner.

## Roadmap

This library is very new and as such lacks many essential features and will most likely fail
spectacularly if used in anything resembling production. The below list enumerates the features
which I have currently identified as reasonable for the library to have.

- [x] `B b = a.Map(); // Variable assignment`
- [x] `a.B = c.Map(); // Property assignment`
- [x] `Process(a.Map()); // Method argument`
- [ ] `new B(a.Map()); // Constructor argument`
- [x] `Process<T>(a.Map(), t); // Mapping to a non-generic type`
- [ ] `Process<T>(a.Map()); // Mapping to type T`
- [x] `_a = b.Map(); // Member assignment`
- [x] `var v = new B { CValue = a.Map() }; // Object initializers`
- [ ] Handle destination types without a public default constructor
- [ ] Recursively map complex types (this will change the behavior of mapping a type to its own type to be a deep copy)
- [ ] Map collections
- [ ] Map properties that can implicitly be converted or is otherwise directly assignable without having the same type
- [ ] Support mapping from a type with more fields than the recipient
- [ ] Handle non-writable properties in the destination and non-readable properties in the source
- [ ] Verify that different mappings will not clash or cause ambiguities
- [ ] Extending the source type with other types, merging the properties into the resulting output

## Features

This library grants all supported types a magical `Map` function which allows instances of the type
to be converted to any type having exactly the same properties. The method will not exist until
you type it out for the first time for a given source and destination type. If no implementation
appears it means that no mapping could be made. This either means that the types do not support
it, for example because they do not have the same properties or that the `Map` function has been
used in an unsupported way. See Known Limitations for more info about the second case.

Example use:

```csharp
var command = new CreateCustomerCommand(name, customerNumber);
Customer customer = command.Map();
```

Mapping to the same type as the source will create a shallow copy of object.

The technical solution to implement the mapping is that `Map` returns object of an intermediary
mapping type which has an implicit conversion operator to each recepient type.

## Known Limitations

If the source class already has a `Map()` method, you cannot map from it.

You cannot map from types which are the product of another map operation. The reason for this
limitation is that source generators cannot understand code generated by source generators, neither
other generators nor itself. Since the return type of the `Map` method is resolved in the second
compilation it cannot be understood by the source generator.

Since the return type of the `Map` method is determined based on how it is used, the library must
handle all possible scenarios explicitly. There are bound to be edge cases which have been
forgotten. If you run into such a case then create an issue and I will look into it. See the Roadmap
sections for the supported scenarios. More scenarios may be supported by happy accident if they are
similar enough to an existing case. Also, if a mathing mapping has already been generated from another
use of the `Map` method, it will become avaiable everywhere regardless if it is supported.

Mapping to values in tuple types is particularly complex, so it is unlikely to make it into 1.0.